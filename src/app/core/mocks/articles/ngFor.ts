export const ngForArticle = {   
  image: "https://www.elite-corner.com/wp-content/uploads/2018/11/angular-ngFor-directive-min.jpg",
  content: [
    `<h1>ngFor - циклический вывод части шаблона Angular<span>детальное описание с примерами</span></h1>`,
    `<p>Директива ngFor одна из самых часто используемых возможностей фреймворка Angular. Она наиболее понятна всем, кто хоть как-то связан с программированием, однако даже опытные программисты иногда упускают некоторые ее особенности или возможности. И так... Приступим.</p>`,
    `<h2>Базоый пример использования директивы ngFor</h2>`,
    `<p>Как видно из названия, директива ngFor представляет собой цикл, который позволяет размножить html элемент и все его дочерние элементы на основе данных массива или объекта. Другими словами, на каждый элемент массива или свойство объекта будет создан html элемент.</p>`,
    `<p>Давайте представим, что нам нужно вывести меню, данные о котором хранятся в массиве:</p>`,
    `<code>const menu = [
  { title: 'home', url: '/' },
  { title: 'blog', url: '/blog' },
  { title: 'goods', url: '/products' },
  { title: 'contacts', url: '/contacts' },
  { title: 'sign in', url: '/sign-in' }
];</code>`,
    `<p>В результате мы хотим получить такую html разметку:</p>`,
    `<code><ul>
  <li><a href="/">home</a></li>
  <li><a href="/blog">blog</a></li>
  <li><a href="/products">goods</a></li>
  <li><a href="/contacts">contacts</a></li>
  <li><a href="/sign-in">sign In</a></li>
</ul></code>`,
    `<p>Используя фреймворк Angular и директиву ngFor, вывод такого меню выглядит довольно просто:</p>`,
    `<code><ul>
  <li *ngFor="let item of menu">
    <a href="{{ item.url }}">{{ item.title }}</a>
  </li>
</ul></code>`,
    `<p>Довольно просто, не правда ли? Конечно, представить всю мощь директивы ngFor на примере 5-ти элементов сложно. Тем более, что данный функционал легко реализовать и с помощью обычного javascript языка.</p>`,
    `<p>Но, давайте представим, что данные заранее неизвестны и приходят из HTTP запроса, их количество может достигать сотен, а то и тысяч объектов, при этом вам нужно строго следить за отрисовкой каждого элемента, чтобы не упала производительность - тут ngFor, да и фреймворк Angular в целом, становятся незаменимыми.</p>`,
    `<h2>Использование ngFor с объектом или Map коллекцией</h2>`,
    `<p>С увеличением количества данных, программисты стараются сократить количество операций, которые связаны с перебором массива. Для этого они создают ассоциативные массивы или по-просту - объекты. Для чего так делается - тема для другой статьи, однако давайте посмотрим на наш пример с меню, в котором данные будут храниться в объекте.</p>`,
    `<code>const menu = {
  'home': '/',
  'blog': '/blog',
  'goods': '/products',
  'contacts: '/contacts',
  'sign in': '/sign-in'
};</code>`,
    `<p>Начиная с версии Angular 6.1 директива ngFor может использовать объекты и коллекции Map в качестве источника данных. Для этого необходимо использовать keyvalue pipe.</p>`,
    `<p>До версии 6.1, при использовании директивы ngFor с объектом, компилятор выдаст ошибку. Ранее приходилось конвертировать объект в массив, а только потом использовать его известным нам способом.</p>`,
    `<p>Пайп keyvalue под капотом делает тоже самое, однако данная возможность Angular освобождает нас от лишних манипуляций с объектами в компоненте и создания дополнительных свойств класса компонента.</p>`,
    `<p>Для получения такой же разметки меню нам, необходимо немного модифицировать синтаксис html шаблона.</p>`,
    `<code><ul>
  <li *ngFor="let item of menu | keyvalue">
    <a href="{{ item.value }}">{{ item.key }}</a>
  </li>
</ul></code>`,
    `<p>Преимущества: Мы используем объект или Map, что делает работу с большими объемами данных внутри компонента более удобной и производительной.</p>`,
    `<p>Недостатки: Мы не контролируем порядок отображения элементов, так как компилятор выводит значения после сортировки ключей. Это приводит к неожиданным результатам, а также дополнительным усилиям для вывода элементов в нужном порядке.</p>`,
    `<h2>Индекс элементов цикла ngFor</h2>`,
    `<p>Чтобы получить индекс каждого элемента (независимо, используете вы массив, объект или коллекцию) достаточно добавить в директиву ngFor специальный синтаксис</p>`,
    `<code><ul>
  <li *ngFor="let item of menu | keyvalue; let i = index">
    <a class="menu-item-{i}" href="{{ item.value }}">{{ item.key }}</a>
  </li>
</ul></code>`,
    `<p>Теперь в переменной i будет содержаться порядковый номер элемента в массиве, объекте или коллекции. Его можно использовать для задания классам индексов, осуществления подсчетов и т.д.</p>`,
    `<code><ul>
  <li><a class="menu-item-1" href="/">Главная</a></li>
  <li><a class="menu-item-2" href="/blog">Блог</a></li>
  <li><a class="menu-item-3" href="/products">Товары</a></li>
  <li><a class="menu-item-4" href="/contacts">Контакты</a></li>
  <li><a class="menu-item-5" href="/sign-in">Войти</a></li>
</ul></code>`,
    `<p>Не стоит использовать индекс для поиска четных/нечетных или первого/последнего элементов - для этого фреймворк Angular предоставляет уже готовый инструмент.</p>`,
    `<h2>Первый и последний элементы цикла ngFor</h2>`,
    `<p>Для получения первого и последнего элемента нашего набора данных используется следующий синтаксис:</p>`,
    `<code>*ngFor="let item of menu; let first = first"
*ngFor="let item of menu; let ls = last"</code>`,
    `<p>Имена переменным после ключевого слова let можно давать любые в соответствии с правилами языка javascript.</p>`,
    `<p>Теперь у нас есть переменные first и ls, которые будут равны true или false в зависимости от того является ли элемент первым или последним. Эти данные мы можем использовать для своих целей, например, для добавления первому или последнему элементу классов и использования их для стилизирования.</p>`,
    `<h2>Четные и нечетные элементы цикла ngFor</h2>`,
    `<p>По аналогии с первым и последним элементами набора, мы можем получить данные о том, четный или нечетных элемент. Для этого используем уже готовый синтаксис по аналогии с предыдущими:</p>`,
    `<code>*ngFor="let item of menu; let ev = even"
*ngFor="let item of menu; let odd = odd"</code>`,
    `<p>Чтобы лучше всего представить, зачем нам могут понадобиться четные и нечетные переменные, представьте, что вам нужно закрасить каждую вторую строку в таблице другим цветом.</p>`,
    `<h2>Улучшаем производительность приложения с trackBy</h2>`,
    `<p>Зачем многие проекты используют фреймворк Angular или подобные? Все дело не только в удобстве формирования HTML разметки на основе данных, но и во многом производительности.</p>`,
    `<p>Представьте, что у вас таблица, в которой 20 колонок и 1000 строк. Это значит, что на странице будет 20*1000 = 20000 ячеек, каждая из которых будет перерисовываться при каком либо изменении в наборе данных. При этом браузер может не просто проиграть в производительности, он может начать банально тормозить. Все дело в механизме отрисовки DOM дерева HTML элементов, о котором подробно написано в статье "Манипуляции с DOM деревом и почему его изменения затратные для браузера".</p>`,
    `<p>Если времени читать одну из самых важных тем для frontend разработчика нет, то в двух словах проблему перерисовки набора элементов можно описать так:</p>`,
    `<p>Изменяя массив меню (добавляя новый, удаляя или меняя порядок существующих), компилятор отрисовывает не только один LI элемент, а все UL меню со всеми дочерними пунктами меню (в нашем примере это 11 HTML элементов). Опять же, представьте, что у вас 20000 ячеек каждая из которых состоит из 2-3 html элементов.</p>`,
    `<p>Для отслеживания, какой элемент необходимо отрисовать, Angular содержит полезное свойство директивы ngFor - trackBy.</p>`,
    `<code>*ngFor="let item of menu; trackBy: getUniqueId"</code>`,
    `<p>В этом примере getUniqueId - это функция, которая возвращает уникальный идентификатор, по которому Angular отслеживает необходимость обновления пункта меню. В простейшем примере эта функция может выглядеть так:</p>`,
    `<code>public getUniqueId = (index: number, item: any) {
  return item ? item.title.replace(‘ ’, ‘_’) : null
}</code>`,
    `<p>С версии Angular 7.2.7 можно использовать специальный pipe, который позволяет уйти от использования функции.</p>`,
    `<code>*ngFor="let item of menu; trackBy: ('title' | trackByProperty)"</code>`,
    `<p>В данном примере Angular будет трекать элементы меню по title’у. Пайп trackByProperty избавляет нас от использования функции для получения уникального идентификатора.</p>`,
    `<p>Недостаток: Если в свойстве title могут быть одинаковые значения или оно может быть объектом, тогда отслеживание уникального элемента может работать неправильно.</p>`,
    `<h2>Использование ngFor с Observable потоками RxJs</h2>`,
    `<p>soon…</p>`,
    `<h2>Как скрыть элементы меню в цикле ngFor</h2>`,
    `<p>soon…</p>`,
  ]
};
